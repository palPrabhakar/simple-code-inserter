#pragma once
#include "clang/Tooling/Refactoring/AtomicChange.h"
#include "clang/Tooling/Transformer/RewriteRule.h"
#include <clang/ASTMatchers/ASTMatchers.h>
#include <clang/Basic/CharInfo.h>
#include <clang/Frontend/FrontendAction.h>
#include <clang/Tooling/CommonOptionsParser.h>
#include <clang/Tooling/Transformer/Stencil.h>
#include <cwctype>
#include <llvm/ADT/StringRef.h>

namespace sci {
using ::clang::ast_matchers::compoundStmt;
using ::clang::ast_matchers::functionDecl;
using ::clang::ast_matchers::hasAncestor;
using ::clang::ast_matchers::hasParent;
using ::clang::ast_matchers::isDefinition;
using ::clang::ast_matchers::isExpansionInMainFile;
using ::clang::ast_matchers::isInStdNamespace;
using ::clang::ast_matchers::returns;
using ::clang::ast_matchers::returnStmt;
using ::clang::ast_matchers::unless;
using ::clang::tooling::AtomicChange;
using ::clang::tooling::AtomicChanges;
using ::clang::tooling::CommonOptionsParser;
using ::clang::transformer::ASTEdit;
using ::clang::transformer::cat;
using ::clang::transformer::makeRule;
using ::clang::transformer::name;
using ::clang::transformer::node;
using ::clang::transformer::statements;

class Actions {
  static auto getIncludeAction() {
  };


};

class CodeInserterTool {
public:
  CodeInserterTool(bool end = false) : m_end(end) {}
  bool run(CommonOptionsParser &);
  bool applySourceChanges();

private:
  AtomicChanges m_changes;
  bool m_end;

  clang::transformer::RewriteRule getRule() {
    // std::vector<ASTEdit> actions;
    // actions.emplace_back(
    //     insertAfter(statements("fn"),
    //                 cat("std::cout<<\"", name("fname"), "\"<<std::endl;")));
    // actions.emplace_back(
    //     addInclude("iostream", clang::transformer::IncludeFormat::Angled));

    auto matcher = compoundStmt(hasParent(functionDecl(isDefinition(),
                                                       isExpansionInMainFile())
                                              .bind("fname")))
                       .bind("fn");

    if (m_end) {
      // actions.emplace_back(
      //     insertAfter(statements("fn"),
      //                 cat("std::cout<<\"", name("fname"),
      //                 "\"<<std::endl;")));

      auto match_non_void =
          returnStmt(
              hasAncestor(functionDecl(isExpansionInMainFile(), isDefinition())
                              .bind("fname")))
              .bind("rtn");
      auto action_rtn =
          insertBefore(node("rtn"), cat("std::cout<<\"end: ", name("fname"),
                                        "\"<<std::endl;"));
      return clang::transformer::applyFirst(
          {makeRule(std::move(matcher), std::move(actions)),
           makeRule(std::move(match_non_void), std::move(action_rtn))});

    } else {
      return makeRule(std::move(matcher), std::move(actions));
    }
  }

  auto getConsumer() {
    return [&](llvm::Expected<llvm::MutableArrayRef<AtomicChange>> C) {
      if (C) {
        m_changes.insert(m_changes.end(), std::make_move_iterator(C->begin()),
                         std::make_move_iterator(C->end()));
      } else {
        llvm::errs() << "Error generating changes: "
                     << llvm::toString(C.takeError()) << "\n";
      }
    };
  }
};
} // namespace sci
